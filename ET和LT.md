epoll中有两种触发机制,LT和ET，一般默认时LT，今天分析下LT和ET的一些问题





## EPOLLONESHOT
&emsp;&emsp;多线程在处理，一个SOCKET事件到来，数据开始解析，这时候这个SOCKET又来了同样一个这样的事件，而你的数据解析尚未完成，那么程序会自动调度另外一个线程或者进程来处理新的事件，这造成一个很严重的问题，不同的线程或者进程在处理同一个SOCKET的事件，这会使程序的健壮性大降低而编程的复杂度大大增加！！即使在ET模式下也有可能出现这种情况！！<br/>
&emsp;&emsp;第一种方法是接收数据和解析数据分为两个线程处理 <br/>
&emsp;&emsp;第二种方法就是本文要提到的EPOLLONESHOT这种方法，可以在epoll上注册这个事件，注册这个事件后，如果在处理完当前的SOCKET后不再重新注册相关事件，那么这个事件就不再响应了或者说触发了。要想重新注册事件则需要调用epoll_ctl重置文件描述符上的事件，这样前面的socket就不会出现竞态。这样就可以通过手动的方式来保证同一SOCKET只能被一个线程处理，不会跨越多个线程
<br/>
###非阻塞模式下的accept该用什么触发模式？<br/>
&emsp;&emsp;LT和ET各有优缺点。使用哪种模式取决于并发量。当并发量比较小时，比较推荐LT，因为LT模式下应用的读写逻辑比较简单，不容易遗漏事件，代码不易出错好维护，而且性能损失不大。当并发量非常大时，推荐使用ET模式，可以有效提升EPOLL效率。
<br/>
### ET比LT更高效得原因<br/>
&emsp;&emsp;ET在通知用户后，就会把fd从就绪队列里删除。而LT通知用户后fd还在就绪链表中，随着fd的增多，就绪链表越大。下次epoll要通知用户时还需要遍历整个就绪链表。遍历的性能是线性，如果fd的数量非常多，就会带来比较显著的效率下降。
同样数量的fd下，LT模式维护的就绪链表比ET的大。<br/>


### sleep和阻塞
#### 阻塞：
&emsp;&emsp;正在执行的进程由于发生某时间（如I/O请求、申请缓冲区失败等）暂时无法继续执行。此时引起进程调度，OS把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种状态称为阻塞状态。

#### 挂起：
&emsp;&emsp;由于系统和用户的需要引入了挂起的操作，进程被挂起意味着该进程处于静止状态。如果进程正在执行，它将暂停执行，若原本处于就绪状态，则该进程此时暂不接受调度。

#### 共同点：
&emsp;&emsp;进程都暂停执行<br/>
&emsp;&emsp;进程都释放CPU，即两个过程都会涉及上下文切换<br/>
#### 不同点：
&emsp;&emsp; 对系统资源占用不同：虽然都释放了CPU，但阻塞的进程仍处于内存中，而挂起的进程通过“对换”技术被换出到外存（磁盘）中。<br/>
&emsp;&emsp; 发生时机不同：阻塞一般在进程等待资源（IO资源、信号量等）时发生；而挂起是由于用户和系统的需要，例如，终端用户需要暂停程序研究其执行情况或对其进行修改、OS为了提高内存利用率需要将暂时不能运行的进程（处于就绪或阻塞队列的进程）调出到磁盘<br/>
&emsp;&emsp; 恢复时机不同：阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其主动激活<br/>

### fork函数<br/>
创建过程:<br/>
(1)给新的进程分配一个标识符<br/>
(2)给内核分配一个PCB,将他挂载到PCB表上<br/>
(3)负责父进程的环境(PCB中的大部分内容)<br/>
(4)分配资源<br/>
(5)复制父进程地址空间的内容(代码共享，数据写时复制)<br/>
(6)将进程设置为就绪状态,放入就绪队列,等待cpu调度<br/>


### 系统如何提高并发性？
1、提高CPU并发计算能力 <br/>
（1）多进程、多线程 <br/>
（2）减少进程切换，使用线程，考虑进程绑定CPU <br/>
（3）减少使用不必要的锁，考虑无锁编程 <br/>
（4）考虑进程优先级 <br/>
（5）关注系统负载 <br/>
2、改进I/O模型 <br/>
（1）DMA技术<br/>
（2）异步I/O<br/>
（3）改进多路I/O就绪通知策略，epoll <br/>
（4）Sendfile <br/>
（5）内存映射 <br/>
（6）直接I/O<br/>

### 为什么析构函数要是虚函数？为什么C++默认的析构函数不是虚函数

1.析构函数不一定必须是虚函数，是否为虚函数取决于该类的使用，一般该类为基类产生继承和多态时，才会是虚函数，单独使用可以不是虚函数。之所以在继承和多态时设计为虚函数是因为当new派生类并且用基类指针指向这个派生类，在销毁基类指针时只会调用基类的析构函数，不会调用派生类的析构函数，因为基类无法操作派生类中非继承的成员，这样就造成派生类只new无法delete造成内存泄露。<br/>
2.默认不是虚析构函数是因为如果析构函数为虚函数就需要编译器在类中增加虚函数表来实现虚函数机制，这样所需内存空间就更大了，因此没有必要默认为虚析构函数。
    
### 僵尸进程和孤儿进程
1、僵尸进程:父进程fork出子进程之后,子进程退出时，由于系统会释放进程的资源，包括打开的文件，所占用的内存，但是会保留该进程的一些信息，包括进程号，进程退出状态等。只有父进程调用wait/waitpid函数来来获取时才会被释放。所以要是父进程不调用wait函数,那么那段信息不能被释放，进程号就会被占用。由于系统的进程号有限，要是有大量的僵死进程，那么会导致没有多余的进程号创建新的线程.<br/>

2、孤儿进程是父进程退出，然而子进程还在运行，那么这些子进程就变成孤儿进程。然后被init进程收养，然后init循环遍历wait即将退出的子进程，结束进程的生命。<br/>
3、如何处理太多的僵尸进程<br/>
（1）通过信号机制
    子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。
（2） fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收还要自己做。

### new和maclloc的区别
（1）new申请的内存是自由存储区，可能是在堆，也可能是在静态存储区，malloc是在堆中<br/>
（2）安全性上，new返回类型具有安全性，malloc是返回的void *类型，需要我们自己去强制去转换的<br/>
（3）内存分配失败是，new会爆出异常bad_alloc，malloc会返回空<br/>
（4）当不分配数组时,new不需要指出内存大小，malloc需要指出分配的类型的大小<br/>
（5）new需要使用构造函数，delete需要使用析构函数<br/>
（6）设置数组的时候，new设置直接输入数组的个数，malloc需要设置手动设置分配的大小，类型的大小和他的个数<br/>
（7）new和delete的实现基于malloc和free<br/>
（8）new和delete可以被重载<br/>
（9）重新分配内存：在使用malloc分配内存时，发现内存不足，使用realloc进行重新分配，首先检查当前位置后面时候还有内存，如果有的话，扩大原有的内存空间，返回原来的指针，空间不足时，按照新地址的指针分配空间，先把原先的位置上的数据拷贝到新的空间，然后释放原来的空间。<br/>
（10）处理内存分配不足时<br/>


### 构造函数不为虚函数
（1）从存储空间角度来看,虚函数表是在存储对象的内存空间,如果构造函数是虚函数,那么就需要虚函数表来调用,但是对象没有实例化,内存空间还没出来,无法找到虚函数表,所以构造函数不能是虚函数.
（2）在创建一个对象的时候,需要明确对象的类型,景观我们可能通过
（3）实际上,虚函数表是在调用了构造函数之后才建立的,所以构造函数不能是虚函数
（4）当一个构造函数被调用时,它的首要事情就是初始化他的虚函数表,